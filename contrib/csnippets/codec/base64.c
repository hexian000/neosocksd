/* csnippets (c) 2019-2024 He Xian <hexian000@outlook.com>
 * This code is licensed under MIT license (see LICENSE for details) */

#include <assert.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

static const unsigned char encoding_table[64] =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

bool base64_encode(
	unsigned char *dst, size_t *dstlen, const unsigned char *src,
	const size_t srclen)
{
	assert(dst != src);
	const size_t outlen = 4 * ((srclen + 2) / 3);
	if (outlen < srclen) {
		*dstlen = 0;
		return false;
	}
	if (*dstlen < outlen) {
		*dstlen = outlen;
		return false;
	}

	size_t r = 0, w = 0;
	while (r < srclen) {
		const uint_fast32_t octet_a = r < srclen ? src[r] : 0;
		r++;
		const uint_fast32_t octet_b = r < srclen ? src[r] : 0;
		r++;
		const uint_fast32_t octet_c = r < srclen ? src[r] : 0;
		r++;

		const uint_fast32_t triple =
			(octet_a << 0x10) + (octet_b << 0x08) + octet_c;
		dst[w++] = encoding_table[(triple >> 3 * 6) & 0x3F];
		dst[w++] = encoding_table[(triple >> 2 * 6) & 0x3F];
		dst[w++] = encoding_table[(triple >> 1 * 6) & 0x3F];
		dst[w++] = encoding_table[(triple >> 0 * 6) & 0x3F];
	}
	w -= r - srclen;
	while (w < outlen) {
		dst[w++] = '=';
	}

	*dstlen = outlen;
	return true;
}

static const unsigned char decoding_table[] = {
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x3E, 0x80, 0x80, 0x80, 0x3F,
	0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x80, 0x80,
	0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12,
	0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24,
	0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
	0x31, 0x32, 0x33, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80,
};

bool base64_decode(
	unsigned char *dst, size_t *dstlen, const unsigned char *src,
	const size_t srclen)
{
	if (srclen == 0) {
		*dstlen = 0;
		return true;
	}
	if (srclen % 4 != 0) {
		*dstlen = 0;
		return false;
	}

	size_t outlen = srclen / 4 * 3;
	if (src[srclen - 1] == '=') {
		outlen--;
	}
	if (src[srclen - 2] == '=') {
		outlen--;
	}
	if (*dstlen < outlen) {
		*dstlen = outlen;
		return false;
	}

	size_t r = 0, w = 0;
	while (r < srclen) {
		const uint_fast32_t sextet_a = decoding_table[src[r++]];
		const uint_fast32_t sextet_b = decoding_table[src[r++]];
		const uint_fast32_t sextet_c = decoding_table[src[r++]];
		const uint_fast32_t sextet_d = decoding_table[src[r++]];
		if ((sextet_a | sextet_b | sextet_c | sextet_d) & 0x80) {
			*dstlen = outlen;
			return false;
		}

		const uint_fast32_t triple =
			(sextet_a << 3 * 6) + (sextet_b << 2 * 6) +
			(sextet_c << 1 * 6) + (sextet_d << 0 * 6);

		if (w < outlen) {
			dst[w++] = (triple >> 2 * 8) & 0xFF;
		}
		if (w < outlen) {
			dst[w++] = (triple >> 1 * 8) & 0xFF;
		}
		if (w < outlen) {
			dst[w++] = (triple >> 0 * 8) & 0xFF;
		}
	}

	*dstlen = outlen;
	return true;
}
